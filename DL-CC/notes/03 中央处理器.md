# Chapter 03 中央处理器



**崔家才 201220014**



## 1 CPU概述

### 1.1 CPU基本功能

**指令周期**：CPU取出并执行一条指令的时间

一条指令的执行过程：

- 取指令：以PC为地址访问主存取出指令送到**指令寄存器(IR)**
- 对IR中的指令操作码译码并计算吓一跳指令地址
- 计算源操作数地址并取源操作数
  - **储存器数据**：需要一次或多次访存
  - **寄存器数据**：直接从寄存器取数
- 对操作数进行相应的运算
- 计算目的操作数地址并存结果

> 上述过程中的第一第二步，所有的指令都一样，都是取指令、指令译码和修改PC；
>
> 剩余步骤由第二步译码得到的控制信号控制。

上述基本操作可以用**寄存器传送级(Register Transfer Level, RTL)语言**描述。

### 1.2 CPU基本组成

两大基本组成部分：**数据通路(datapath)**和**控制器/控制部件(control unit)**。

**执行部件(execution unit)**：数据通路中专门进行数据运算的部件，包括**组合逻辑元件/操作元件**和**储存元件/状态元件**。

**数据通路(datapath)**：由操作元件和储存元件通过总线或分散连接方式连接而成的进行数据存储、处理和传送的路径。

#### 1.2.1 组合逻辑元件

组合逻辑元件属于组合逻辑电路，输出只取决于当前输入。

常用的组合逻辑元件：

**多路选择器(MUX)**，需要控制信号Select；**加法器(Adder)**；**算术逻辑部件(ALU)**，需要控制信号OP

#### 1.2.2 状态元件

状态元件属于时序电路，具有储存功能，输入状态在时钟控制下被写道电路中，并保持电路的输出值不变，直到下一个时钟到达。输入状态由时钟信号决定何时被写入，输出状态可以随时读出。

**建立时间(setup time)**：在时钟下降沿（以下降沿触发为例）到达前的一段输入端D的状态必须稳定有效的时间

**保持时间(hold time)**：时钟下降沿（以下降沿触发为例）到达后的一段输入端D的状态必须保持稳定不变的时间

**锁存延迟(Clk-to-Q time)**：满足建立时间和保持时间约束后输出端状态Q转变为D所需的时间

**暂存寄存器**：有一个**写使能(Write Enable, WE)**，当WE为1时，**时钟信号(Clk)**边沿到来时，经过Clk-toQ时间的延迟，**输出端(DataOut)**开始变为**输入端(DataIn)**的值，表示输入信息被写入寄存器。如果数据通路中某个寄存器在每个时钟周期到来时都需要写入信息，则无需WE信号。

**通用寄存器组(General Purpose Register set, GPRs)**：32个暂存寄存器可以构成一个通用寄存器组，每个寄存器地址是一个5位二进制编码，它有两个读口：32位`busA`和`busB`分别由5位`RA`和`RB`给出地址；一个写口：32位`busW`上的信息写入由5位`RW`给出地址的寄存器。读操作为组合逻辑，经过一个取数时间的延迟，在busA和busB上的信息便开始有效；写操作为时序逻辑，需要时钟信号Clk的控制，在WE为1时经过Clk-to-Q延迟，从busW传来的值便开始写入RW指定的寄存器中。

### 1.3 数据通路与时序控制

**早期计算机的三级时序系统**：机器周期、节拍和脉冲

**现代计算机的时钟信号**：一个时钟周期就是一个节拍。数据通路可以看成由组合逻辑元件和状态元件交替组成，只有状态元件能够储存信息，所有状态元件在同一时钟控制下写入信息。假定各级组合逻辑电路的传输延迟(即最长延迟)为longest dely，考虑时钟偏移clock skew，则数据通路的时钟周期应为cycle time = Clk-to-Q + longest delay + setup time + clock skew。假定各级组合逻辑电路的最短传输延迟为shortest delay，为了使数据通路能够正常工作，则应满足以下下时间约束：Clk-to-Q + shortest delay > hold time。

### 1.4 计算机性能与CPU时间

**吞吐率(throughput)**：单位时间内所完成的工作量

**带宽(bandwidth)**：单位时间内传输的信息量

**响应时间(response time)**：从作业提交开始到作业完成所用的时间

**执行时间(execution time)**和**等待时间(latency)**：一个任务所用时间的度量值

用户感觉到的执行时间分为：**用户CPU时间/CPU执行时间**和其他时间。

CPU时间计算需要的指标和概念：

- **时钟周期(clock cycle)**：用于CPU操作同步定时的时钟信号的宽度
- **时钟频率(clock rate)**：时钟周期的倒数，又称**主频**
- **CPI(Cycles Per Instruction)**：执行一条指令所需的时钟周期数

```
用户CPU时间 = 程序总时钟周期数 / 时钟频率 = 程序总时钟周期数 * 时钟周期
程序总时钟周期数 = 程序总指令数 * CPI (指令CPI相同) = ∑(C * CPI)
平均CPI = 程序总时钟周期数 / 程序总指令条数 = ∑(F * CPI)
```



## 2 单周期CPU

### 2.1 指令功能描述

**R-型指令**

| 指令              | 功能                                                         |
| ----------------- | ------------------------------------------------------------ |
| add rd, rs1, rs2  | M[PC], PC <- PC + 4<br />R[rd] <- R[rs1] + R[rs2]            |
| slt rd, rs1, rs2  | if (R[rs1] < R[rs2]) R[rd] <- 1 (有符号数比较)<br />else R[rd] <- 0 |
| sltu rd, rs1, rs2 | if (R[rs1] < R[rs2]) R[rd] <- 1 (无符号数比较)<br />else R[rd] <- 0 |

**I-型指令**

| 指令               | 功能                                               |
| ------------------ | -------------------------------------------------- |
| ori rd, rs1, imm12 | R[rd] <- R[rs1] \| SEXT(imm12)                     |
| lw rd, rs1, imm12  | Addr <- R[rs1] + SEXT(imm12)<br />R[rd] <- M[Addr] |

**U-型指令**

| 指令          | 功能                     |
| ------------- | ------------------------ |
| lui rd, imm20 | R[rd] <- imm20 \|\| 000H |

**S-型指令**

| 指令               | 功能                                                |
| ------------------ | --------------------------------------------------- |
| sw rs1, rs2, imm12 | Addr <- R[rs1] + SEXT(imm12)<br />M[Addr] <- R[rs2] |

**B-型指令**

| 指令                | 功能                                                         |
| ------------------- | ------------------------------------------------------------ |
| beq rs1, rs2, imm12 | Cond <- R[rs1] - R[rs2]<br />if (Cond eq 0)<br />    PC <- PC + SEXT(imm12) * 2 |

**J-型指令**

| 指令          | 功能                                            |
| ------------- | ----------------------------------------------- |
| jal rd, imm20 | R[rd] <- PC + 4<br />PC <- PC + SEXT(imm20) * 2 |

### 2.2 设计

- 扩展部件的设计

实现立即数的扩展操作：immJ、immU、immS、immB、immJ

- 算术逻辑部件的设计

- 取指令部件的设计
  - 根据PC从主存取指令
  - 下地址逻辑，顺序加4，跳转看具体指令
- 数据通路的设计：由易到难不断扩展数据通路
  - R-型指令：寄存器 + ALU
  - I-型指令：增加扩展器
  - U-型指令：增加扩展器的扩展方式
  - Load/Store指令：增加扩展器的扩展方式，并且增加数据储存器
  - B-型指令：增加PC、指令储存期和下地址逻辑
  - J-型指令：修改下地址逻辑

- 控制器设计
  - 分析每个指令执行所需的控制信号

![image-20210628200452957](C:\Users\23051\AppData\Roaming\Typora\typora-user-images\image-20210628200452957.png)

- 时钟周期的确定
  - CPU执行时间由指令数目、时钟周期和CPI决定
  - 指令数目由编译器和指令系统决定
  - 单周期CPU的CPI为1
  - 时钟周期通常取最复杂的指令的执行周期，在给出的9条指令中，最复杂的是lw指令
    - PC所存延迟(Clk-to-Q) + 取指令时间 + 寄存器取数时间 + ALU延迟 + 储存器取数时间 + 寄存器建立时间 + 时钟偏移



## 3 多周期CPU

**基本思想**：

- 把每条指令的执行分成多个阶段，每个阶段在一个或多个时钟周期内完成
  - 取指令并计算下条指令地址
  - 译码并取数
  - 执行指令
- 每个时钟周期称为一个状态，期间最多完成一次访存或一次寄存器读写或一次ALU操作
- 每个时钟内的执行结果在下个时钟到来时，保存到相应储存元件或稳定地保持在组合电路中
- 时钟周期的宽度以最复杂阶段所用的时间为准

**多周期控制器**：通常采用基于有限状态机的描述和微程序描述两种方式

**有限状态机控制器/组合逻辑控制器/PLA控制器/硬连线控制器**：输入：指令操作码OP + 状态寄存器；输出：控制信号 + 下一状态；输入和输出之间是一个纯组合逻辑，时序逻辑只存在于状态寄存器中

**微程序控制器**：将每条指令的过程用一个**微程序**来表示，每个微程序由若干条**微指令/控制字(Control Word, CW)/微命令**(微地址码 + 微操作码)，对应着若干个**微操作**组成，所有指令对应的微程序都存放在一个ROM中，这个ROM称为**控制储存器/控存(Control Storage, CS)**，控存中的信息称为**微代码**。优点：更灵活；缺点：更慢。

**带异常处理的CPU设计**：当CPU在执行当前程序或任务（即用户进程）的第i条指令时，若检测到一个异常事件，或在执行第i条指令后发现有一个中断请求信号，则CPU会中断当前程序的执行，跳转到操作系统中相应的异常或中断处理程序去执行。若异常或中断处理程序能够解决相应问题，则在异常或中断处理程序的最后，CPU通过执行“异常/中断”返回指令回到被打断的用户进程第i条或i+1条指令继续执行；若异常或中断处理程序发现的是不可恢复的致命错误，则终止用户进程。



## 4 流水线CPU设计

### 4.1 流水线CPU概述

**指令流水线**：一般由如下5个流水段组成

- **取指令(Instruction Fetch, IF)**：从储存器取指令
- **指令译码(Instruction Decode, ID)**：产生指令所需的控制信号
- **取操作数(Operand Fetch, OF)**：读取储存器操作数或寄存器操作数
- **执行(Execution, EX)**：对操作数完成相应操作
- **写回(Write Back, WB)**：将操作结果写回存储器或寄存器

> 后一条指令的第i步和前一条指令的第i+1步同时进行，从而使完成一串指令总的完成时间大为缩短。
>
> 例如对于上述五段流水线指令，完成4条，以流水线方式只需8个时钟周期，若以非流水线方式，则需20个时钟周期。

理想情况下，每个时钟都有一条指令进入流水线，每个时钟都有一条指令完成，则每条指令的CPI为1。

规整、简单、一致等特性有利于指令的流水线执行。

### 4.2 指令的流水段分析

- **取指令(IF)**：从主存取指令并计算PC+4
- **指令译码(ID)**：产生指令执行所需的控制信号，并生成操作数，包括寄存器取数和立即数扩展
- **执行(EX)**：对操作数完成指定操作
- **访存(M)**：访问储存器
- **写回(WB)**：将结果写回寄存器

| 指令类型 | 功能段划分            |
| -------- | --------------------- |
| R-型指令 | IF + ID + EX + WB     |
| I-型指令 | IF + ID + EX + WB     |
| U-型指令 | IF + ID + EX + WB     |
| lw指令   | IF + ID + EX + M + WB |
| S-型指令 | IF + ID + EX + M      |
| B-型指令 | IF + ID + EX + M      |
| J-型指令 | IF + ID + EX + WB     |

### 4.3 流水线数据通路的设计

**流水段寄存器**：用于存放从当前流水段传到后面所有流水段的信息

IF是公共流水段，不需要控制信号，其余段的控制信号如下：

- ID段
  - **扩展器类型(ExtOp))**：3位编码
- EX段
  - **ALU的A口来源(ALUASrc)**：1，来源于PC；0来源于busA
  - **ALU的B口来源(ALUBSrc)**：00，来源于busB；01，来源于常数4；10，来源于扩展器
  - **ALU运算类型(ALUctr)**：4位编码
- M段
  - **数据储存器DM的写信号(MemWr)**：S-型指令时为1，其他指令为0
  - **是否为B-型分支指令(Branch)**：B-型指令时为1，其他指令为0
  - **是否为J型跳转指令(Jump)**：J-型指令时为1，其他指令为0
- WB段
  - **寄存器的写入源(MemtoReg)**：1，DM输出；0，ALU输出
  - **通用寄存器写信号(RegWr)**：结果写寄存器的指令都为1，其他指令为0



## 5 流水线冒险及其处理

### 5.1 结构冒险

**结构冒险(structural hazard)/硬件资源冲突(hardware resource conflict)**：同一个部件同时被不同指令所使用的硬件资源竞争

解决：

- 流水线(段划分原则->一个部件每条指令只能用一次)
- 设置多个独立部件(比如将Rrd和Rwr独立开来)

### 5.2 数据冒险

**数据冒险(data hazard)/数据相关(data dependencies)**：后面指令用到前面指令的结果时，前面指令的结果还没产生(比如说，第一条指令的结果要在WB段产生，但是第二条指令的ID段就需要第一条指令的结果了，而此时第一条指令才刚刚运行到EX段，结果还未产生)，这种冒险称为**写后读(Read After Write, RAW)数据冒险**。

可采取的措施：

- 插入**空操作指令nop**

  - 控制简单
  - 但浪费了指令储存空间和指令执行时间

- 插入**气泡(bubble)**

  - 通过硬件**阻塞(stall)**的方式阻止后续指令执行

- **转法(forwarding)/旁路(bypassing)技术**

  - 将数据通路中生成的中间数据直接发送到ALU的输入端

- Load-use数据冒险的检测和处理

  > lw指令之后跟R-型指令或I-型指令的相关性问题

  - 在load指令之前插入nop指令来解决
  - 调整指令顺序以避免Load-use现象

### 5.3 控制冒险

**控制冒险(control hazard)**：由于发生了执行顺序改变而引起的流水线阻塞

**分支冒险(branch hazard)**：由于指令分支而引起的控制冒险

- 软件阻塞：插入nop
- 硬件阻塞：插入stall
- **静态预测(static prediction)/简单预测**和**动态预测(dynamic prediction)**
  - 动态的准确率可达90%
- **延迟分支(delayed branch)**：将和分支指令无关的指令放到分支指令之后执行，避免阻塞的情况，由编译器完成此过程
- 异常和中断引起的控制冒险



## 6 高级流水技术

**超流水线(super-pipelining)技术**：通过增加流水线技术来使更多的指令同时在流水线中重叠执行

**多发射流水线(multiple issue pipelining)技术**：同时发射多条指令的流水线，数据通路中有多个执行部件

**静态多发射**：**VLIW(Very Long Instruction Word, 超长指令字)结构**、编译器静态推测

**动态多发射**：超标量结构、硬件动态推测调度

























