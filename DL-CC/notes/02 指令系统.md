# Chapter 02 指令系统



**崔家才 201220014**



## 1 指令系统概述

**指令集体系结构(Instruction Set Architecture, ISA)**：一台计算机的抽象模型，位于软件和硬件之间的交界面，是构成程序的基本元素，也是硬件设计的依据，简称**指令系统**。



## 2 指令系统设计

### 2.1 操作数和寻址方式

**形式地址A**：指令中的地址码字段

**有效地址EA**：指令中给出的操作数所在储存单元的地址

**寻址方式**：指令给出操作数或操作数地址的方式称为寻址方式

**立即寻址**：指令中直接给出操作数本身(**立即数**)

**直接寻址**：形式地址是操作数的有效地址(**直接地址/绝对地址**)，`EA=A`

**间接寻址**：形式地址是有效地址的地址，`EA=(A)`，符号(x)表示寄存器编号x或者储存单元地址x中的内容

**寄存器寻址/寄存器直接寻址**：形式地址是操作数所在的寄存器编号，`EA=A`

- 寄存器编号比储存器地址短
- 操作数已在CPU中，不用访存，执行速度快

**寄存器间接寻址**：形式地址是有效地址的寄存器编号，`EA=(A)`

**变址寻址**：形式地址是**基准地址A**，**变址寄存器I**中存放的是**偏移量/位移量**。有效地址`EA=A+(I)`

**相对寻址**：形式地址A给出偏移量，基准地址隐含由PC给出，`EA=(PC)+A`

**基址寻址**：形式地址A给出偏移量，基准地址由**基址寄存器B**给出，`EA=(B)+A`

> 变址寻址、相对寻址、基址寻址统称为**偏移寻址**。

### 2.2 操作类型

- **算术和逻辑运算指令**

  加(ADD)、减(SUB)、比较(CMP)、乘(MUL)、除(DIV)、与(AND)、或(OR)、取反(NOT)、取负(NEG)、异或(XOR)、加1(INC)、减1(DEC)等

- **移位指令**

  算术移位、逻辑移位、循环移位、半字交换

- **数据传送指令**
  - MOV：寄存器之间的传送
  - LOAD：从内存单元读数据到寄存器
  - STORE：从寄存器写数据到内存单元
- **串指令**：对字符串进行操作的指令
- **顺序控制指令**
  - 有条件转移(BRANCH)、无条件转移(JMP)、调用(CALL)、返回(RET)
  - 通过将转移目标地址送到PC中来实现
    - **绝对转移**：转移目标地址用直接寻址方式给出
    - **相对转移**：转移目标地址用相对寻址方式给出
  - **无条件转移指令**：在任何情况下都执行转移操作
  - **条件转移指令/分支指令**：在满足特定条件时才执行转移操作
  - **转子指令/调用指令**：用于子程序调用（**过程调用**或**函数调用**），必须保存下条指令的地址（称为**返回地址**）
  - **返回指令**：将实现保存的返回地址传到PC

- **系统指令**
  - 停机、开中断、关中断、系统模式切换、进入特殊处理程序
- **输入输出指令**

### 2.3 操作码编码

**定长操作码**：操作码为固定长度，译码方便，指令执行速度快，但有信息冗余

**变长操作码**：操作码按短到长扩展编码

### 2.4 标志信息的生成和使用

**条件码(Condition Code)/状态位(status)**：标志信息

**程序状态字(Program Status Word, PSW)**：零标志ZF、溢出标志OF、符号标志SF、进位/借位标志CF，可由专门的**条件码寄存器**（或称**状态寄存器**、**标志寄存器**、**程序状态字寄存器**）来存放

### 2.5 指令系统风格

#### 2.5.1 按操作数位置指定风格

- **累加器(Accumulator, AC)**型指令系统
- **栈(Stack)**型指令系统
- **通用寄存器(General Purpose Register)**型指令系统
  - 操作数可以来自：立即数(I)、通用寄存器(R)、储存单元(S)
  - 指令类型可以是：RR型(两个操作数都来自寄存器)、RS型(两个操作数分别来自寄存器和存储单元)、SI型(两个操作数分别来自存储单元和立即数)、SS型(两个操作数都来自储存单元)

- Load/Store型指令系统

#### 2.5.2 按指令格式的复杂度来分

- CISC风格指令系统
  - **复杂指令集计算机(Complex Instruction Set Computer)**：设计指令时使机器指令的功能接近高级语言语句的功能
- RISC风格指令系统
  - **精简指令集计算机(Reduced Instruction Set Computer)**：
    - 指令数目少
    - 指令格式规整
    - 采用Load/Store型指令设计风格
    - 采用大量通用寄存器



## 3 指令系统实例：RISC-V架构

### 3.1 32位RISC-V指令格式

![image-20210626163307286](C:\Users\23051\AppData\Roaming\Typora\typora-user-images\image-20210626163307286.png)

#### 3.1.1 指令类型

- R-型为寄存器操作数指令
- I-型为短立即数操作或取数(Load)指令
- S-型为存数指令
- B-型为条件跳转指令
- U-型为长立即数操作指令
- J-型为无条件跳转指令

#### 3.1.1 指令格式

- 所有指令格式的低7位都为**操作码字段**`opcode`

- 字段`rd`，`rs1`和`rs2`给出的是**通用寄存器编号**
  - 因为RISC-V架构共有32个32位通用寄存器x0~x31，因而寄存器编号占5位
  - 0号寄存器x0的内容永远是0
- `imm`字段给出的是一个**立即数**，其位数在括号[]中表示
- 字段`funct3`和`funct7`分别表示3位和7位**功能码**，它们和`opcode`一起定义指令的操作功能

### 3.2 RTL语言

**寄存器传送级(Register Transfer Level, RTL)**，**RTL语言约定**：

- `R[r]`表示通用寄存器`r`的内容
- `M[addr]`表示储存单元addr的内容
- `M[R[r]]`表示寄存器r的内容所指储存单元的内容
- `PC`表示PC的内容
- `M[PC]`表示PC所指储存单元的内容
- `SEXT[imm]`表示对立即数imm进行符号扩展
- `ZEXT[imm]`表示 对立即数imm进行零扩展
- 传送方向用<--表示，即传送源在右，传送目的在左

### 3.2 基础整数指令集RV321

#### 3.2.1 整数运算类指令

- U-型指令一共有两条：

```python
lui rd, imm20 #R[rd] <- imm20 || 000H //符号||表示拼接
```

该指令和`addi rd, rs1, imm12`指令结合，可以实现对一个32为变量赋初值。

当`imm12`第一位为1的时候，注意符号扩展带来的影响。

```python
auipc rd, imm20 #将立即数imm20加到PC的高20位上，结果存rd
```

可用指令`auipc x10, 0`将PC的值存入寄存器x10中。

- I-型指令助剂符都带`i`，表示一个操作数为立即数

```python
addi rd, rs1, imm12 #R[rd] <- R[rs1] + SEXT[imm12]
```

> 因为addi指令可以直接加一个负数，因而无需提供subi指令

- R-型指令的两个操作数所在的寄存器总是rs1和rs2，结果寄存器为rd

```python
sub rd, rs1, rs2 #R[rd] <- R[rs1] - R[rs2]
```

- RV32I指令集提供了(and, andi)、或(or, ori)、异或(xor, xori)三种共6条逻辑运算指令
- 移位指令

```python
sll rd, rs1, rs2 #R[rd] <- R[rs1] << R[rs2]
slli rd, rs1, shamt #R[rd] <- R[rs1] << shamt
```

> 因为算术左移和逻辑左移的结果完全相同，所以RV32I中没有算术左移指令。

- RV32I提供了4条比较指令：带符号整数小于(slt、slti)和无符号整数小于(sltu、sltiu)。

```python
sltiu rd, rs1, imm12 #R[rd] <- R[rs1] < SEXT[imm12]
```

> imm12的值应该小于2048，因为sltiu将imm12符号扩展后按无符号比较。

#### 3.2.2 控制转移类指令

- 6条分支指令采用B-型格式，其功能为：若rs1和rs2两个寄存器内容比较满足条件，则跳转到目标地址处执行；否则，执行下一条指令。
  - 比较条件包括相等(beq)、不等(bne)、带符号整数小于(blt)、带符号整数大于(bge)、无符号整数小于(bltu)、无符号整数大于(bgeu)。
  - 因指令宽度总是4(RV32G)或2(RV32C)字节，因而总是2的倍数，即指令地址的最低位总是0。因此，`转移目标地址 = PC + SEXT[imm[12:1]<<1]`。
- RV32I中的两条跳转并链接(Jump & Link)指令jal和jalr分别采用J-型指令和I-型指令格式。

```python
jal rd, imm20 #PC <- PC + SEXT[imm[20:1] << 1]; R[rd] <- PC + 4
```

> - 若将返回地址(PC+4)保存到寄存器x1，则可实现过程调用；
> - 若目的寄存器rd指令为x0(x0永远为0，不可更改),则可实现无条件跳转。

```python
jalr rd, rs1, imm12 #PC <- R[rs1] + SEXT[imm12]; R[rd] <- PC + 4
```

> 将目的寄存器rd设为x0时，可以实现switch-case语句的地址跳转；
>
> 若先通过U-型指令装入rs1，则可以实现32位地址空间的绝对或相对跳转。

#### 3.2.3 储存器访问类指令

```python
lw rd, rs1, imm12 #R[rd] <- M[R[rs1] + SEXT[imm12]]
sw rs1, rs2, imm12 #M[R[rs1] + SEXT[imm12]] <- R[rs2]
```

#### 3.2.4 系统控制指令



