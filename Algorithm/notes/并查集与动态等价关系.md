# 并查集与动态等价关系

**201220014 崔家才**



[TOC]



## 动态等价关系

考虑n个元素$a_1, a_2, ..., a_n$，在某种等价关系下被分成若干个等价类。初始时，每个元素单独成为一个等价类。后续等价类会被陆续合并，使用者还需要经常查询某个元素属于哪一个等价类。此时两个操作是关键的：

- $FIND(a_i)$：返回$a_i$所在的等价类（的代表元）。
- $UNION(a_i, a_j)$：将$a_i$和$a_j$所在的等价类合并成一个等价类。

如果我们能高效地获得一个元素所在等价类的代表元，则再做一次代表元比较，即可判断两个元素之间是否具有等价关系。对于并查集的$l$次$UNION/FIND$操作，我们称之为长度为$l$的并查程序，并查集的实现代价是$n$和$l$的函数。



## 基于根树的基础实现：普通“并”+普通“查”

- FIND：反复访问parent节点，返回最顶层的节点作为代表元；
- UNION：将一棵根树缀到另一棵的根结点上；

可能会出现极不平衡的根树，比如说链，最坏复杂度为$O(nl)$。



## 保证合并的平衡性：加权“并” + 普通“查”

对UNION进行朴素的优化，控制总是将节点数更少的树挂到节点数更多的树的根结点上。

初始时，每个元素成为一个等价类，基于WEIGHTED-UNION来实现并查集的并时，包含k个结点的树，它的高度至多不超过$\lfloor\log k\rfloor$。

采用WEIGHTED-UNION和FIND，对于n个元素的并查集与长度为l的并查程序，最坏情况下代价为$O(n + l\log n)$。

> 注：初始化根树需要O(n)。



## 降低查找的代价：加权“并” + 路径压缩“查”

对FIND增加额外操作，当查找一个结点的等价类代表元之后，将这个结点直接挂在代表元下面，这样的话下一次FIND只需要O(1)就行了。

对于包含n个元素的并查集，执行长度为l的WEIGHTED-UNION和C-FIND组成的指令序列，最坏情况时间复杂度为$O((n + l)\log^*n) \approx O(n + l)$。

