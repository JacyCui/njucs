# 分治排序

**201220014 崔家才**



[TOC]



## 快速排序

从分治的角度来说，快速排序是一种典型的难分易合型的分治算法，并且它分割子问题的方法在快速排序之外的很多场合都有重要的应用。

### 插入排序的不足

插入排序基于遍历来实现，它的最坏和平均情况时间复杂度均为$O(n^2)$。但它还有改进的空间，因为每次寻找插入位置所进行比较的信息，未能在下一次插入的时候进行充分的利用。

**逆序对(inversion)**：给定一组各不相同的两两可比较的元素。对于这些元素的一个排列$\{a_1, a_2, ..., a_n\}$而言，定义二元组$(a_i, a_j)$为一个逆序对，如果$i < j$，且$a_i > a_j$。

基于逆序对的概念，我们可以将排序的过程视为消除逆序对的过程。而插入排序的最大问题就是：一次比较只能消除一次逆序对。而一个序列最坏有$O(n^2)$个逆序对，所以需要$O(n^2)$次比较。

### 快速排序的改进

如果想改进排序算法的效率，必须一次比较能够消灭尽可能多的逆序对。

根据逆序对的定义，

- 一个偏大的元素应当尽量往后放，这样它就以更小的可能性与其他元素组成逆序对；
- 同理，一个偏小的元素应当尽量往前放。

而如何界定“偏大”、“偏小”这两个概念，我们选取一个元素作为基准$pivot$。

```pseudocode
procedure PARTITION(A, p, r)
pivot = A[r];
i = p - 1;
for j = p to r - 1 do
	if A[j] < pivot then
		i = i + 1;
		SWAP(A[i], A[j]);
SWAP(A[i + 1], A[r]);
return i + 1;
```

```pseudocode
procedure QUICK_SORT(A, p, r)
if p < r then
	q = PARTITION(A, p, r);
	QUICK_SORT(A, p, q - 1);
	QUICK_SORT(A, p + 1, r);
```

### 最坏情况时间复杂度分析

快速排序性能主要受PARTITION算法影响，如果分割得越均匀，性能越好，反之性能越差。最不均匀的情况下就是每次所有的元素都比pivot大或者小，这样的话每次问题规模只减少了1，于是总复杂度为$O(n^2)$。

如果每次都是均匀的，则$A(n) = 2A(\frac{n}2) + O(n)$，于是$A(n) = n\log n$。

### 基于递归方程的平均情况时间复杂度分析

$$
A(n) = (n - 1) + \sum_{i = 0}^{n - 1} \frac1n[A(i) + A(n - 1 - i)], n\ge 2\\
= n - 1 + \frac2n\sum_{i = 0}^{n - 1}A(i), n\ge 2
$$

最终得到$A(n) = O(n\log n)$。

### 基于指标随机变量的平均情况时间复杂度分析

定义指标随机变量$X_{ij} = I\{z_i和z_j发生了比较\}$，则快排的代价可以表示为：
$$
X = \sum_{i = 1}^{n - 1}\sum_{j = i + 1}^{n}X_{ij}
$$
其中，$z_i$和$z_j$发生比较的概率为$\frac{2}{j - i + 1}$（只有当$z_i$或者$z_j$被选为pivot的时候才会发生）。
$$
E[x] = E[\sum_{i = 1}^{n - 1}\sum_{j = i + 1}^{n}X_{ij}]\\
= \sum_{i = 1}^{n - 1}\sum_{j = i + 1}^{n}E[X_{ij}]\\
=\sum_{i = 1}^{n - 1}\sum_{j = i + 1}^{n}Pr\{z_i和z_j发生了比较\}\\
=\sum_{i = 1}^{n - 1}\sum_{j = i + 1}^{n}\frac2{j - i + 1}\\
=O(n\log n)
$$


## 归并排序

归并排序是一种典型的易分难合的分治算法。这类分治算法主要基于这样的思路：当没有明显的线索提示如何分割子问题时，就直接对子问题进行均匀分割。对于每个子问题，递归地对它们进行求解。当已经获得每个子问题的解的时候，把它们合并称原始问题的解往往比直接求原始问题要容易。

```pseudocode
procedure MERGE(A, p, q, r)
n1 = q - p + 1;
n2 = r - q;
Let L[1..n1 + 1] and R[1..n2 + 1] be new arrays;
for i = 1 to n1 do
	L[i] = A[p + i - 1];
for j = 1 to n2 do
	R[j] = A[q + j];
L[n1 + 1] = INF;
R[n2 + 1] = INF;
i = 1; j = 1;
for k = p to r do
	if L[i] < R[j] then
		A[k] = L[i];
		i = i + 1;
	else
		A[k] = R[j];
		j = j + 1;
```

```pseudocode
procedure MERGE_SORT(A, p, r)
if p < r then
	q = (p + r) / 2;
	MERGE_SORT(A, p, q);
	MERGE_SORT(A, q + 1, r);
	MERGE(A, p, q, r);
```



## 基于比较的排序下界

决策树是一棵2-树（每个结点均有0个或者2个子结点），它的所有内部结点表示的是两个元素$x_1$和$x_2$之间的比较，叶子结点代表最终的结果，树的高度代表比较的次数。

假设一颗二叉树的高度为h，叶结点个数为L，则$L\le 2^{h}$。

排序算法的结果有$n!$种，也就是说决策树至少有$n!$个叶子，于是$n! \le L \le 2^h$，于是$h\ge \log n! = O(n\log n)$。

















